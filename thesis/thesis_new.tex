% Praca dyplomowa - Akcelerator graficzny fixed-pipeline oparty na FPGA
% Autor: Jakub Janeczko
% Promotor: dr Marek Materzok
% Instytut Informatyki, Uniwersytet Wrocławski

\documentclass[inz,shortabstract]{iithesis}

\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}

%%%%% DANE DO STRONY TYTUŁOWEJ
\polishtitle    {Akcelerator graficzny fixed-pipeline\fmlinebreak oparty na FPGA}
\englishtitle   {Fixed-Pipeline Graphics Accelerator\fmlinebreak Based on FPGA}

\polishabstract {%
Niniejsza praca przedstawia projekt i~implementację akceleratora graficznego
o~architekturze fixed-pipeline na platformie FPGA. Zaprojektowany system
realizuje podzbiór funkcjonalności OpenGL ES~1.1 Common-Lite, obejmujący
transformacje geometryczne, system oświetlenia, rasteryzację trójkątów
oraz testy głębokości i~szablonu. Implementacja wykorzystuje język
Amaranth HDL i~jest zintegrowana z~systemem SoC opartym na układzie
Intel Cyclone~V. Praca zawiera szczegółowy opis architektury potoku
graficznego, algorytmów implementowanych w~sprzęcie oraz wyników testów
weryfikujących poprawność działania akceleratora. Rezultatem pracy jest
w~pełni funkcjonalny prototyp, który został zweryfikowany za pomocą
zestawu testów jednostkowych oraz aplikacji demonstracyjnych.
}

\englishabstract{%
This thesis presents the design and implementation of a~fixed-pipeline
graphics accelerator on an FPGA platform. The designed system implements
a~subset of OpenGL ES~1.1 Common-Lite functionality, including geometric
transformations, lighting system, triangle rasterization, and depth and
stencil tests. The implementation uses Amaranth HDL and is integrated
with an SoC system based on Intel Cyclone~V. The thesis contains
a~detailed description of the graphics pipeline architecture,
hardware-implemented algorithms, and test results verifying the
correctness of the accelerator. The result is a~fully functional
prototype, verified through a~set of unit tests and demonstration
applications.
}

\author         {Jakub Janeczko}
\advisor        {dr Marek Materzok}
\advisorgen     {dr. Marka Materzoka}

%%%%% WŁASNE DODATKOWE PAKIETY
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb,amsthm,amsfonts}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning,shapes,calc}
\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}

%%%%% WŁASNE DEFINICJE I POLECENIA
\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    captionpos=b
}

\lstdefinelanguage{Amaranth}{
    keywords={def, class, return, if, else, elif, for, while, in, import, from, as, with, yield, async, await},
    morecomment=[l]{\#},
    morestring=[b]",
    morestring=[b]'
}

\theoremstyle{definition}
\newtheorem{definition}{Definicja}[chapter]

\hyphenation{Ama-ranth FPGA Cy-clone Open-GL ra-ste-ry-za-cja}

%%%%%

\begin{document}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={Akcelerator graficzny fixed-pipeline oparty na FPGA},
    pdfauthor={Jakub Janeczko}
}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Wprowadzenie}

\section{Kontekst i motywacja}

Grafika komputerowa jest jedną z~najważniejszych dziedzin współczesnej
informatyki, znajdującą zastosowanie w~szerokim spektrum aplikacji --
od gier wideo i~wizualizacji naukowych, przez systemy wspomagania
projektowania (CAD), po symulacje medyczne i~rzeczywistość wirtualną.
Wraz z~rosnącymi wymaganiami dotyczącymi wydajności i~jakości renderingu,
akceleratory graficzne stały się nieodzownym elementem większości
systemów komputerowych.

Tradycyjnie akceleratory graficzne są implementowane jako
wyspecjalizowane układy scalone (ASIC) lub karty graficzne (GPU).
Układy te, choć niezwykle wydajne, charakteryzują się znacznymi
kosztami rozwoju oraz brakiem elastyczności -- po wyprodukowaniu
niemożliwa jest modyfikacja ich funkcjonalności. W~przeciwieństwie
do nich, układy FPGA (Field-Programmable Gate Array) oferują możliwość
implementacji złożonych systemów cyfrowych z~pełną rekonfigurował\-nością,
co pozwala na iteracyjny rozwój oraz dostosowanie architektury do
specyficznych wymagań aplikacji.

Niniejsza praca powstała z~przekonania, że platformy FPGA stanowią atrakcyjną alternatywę dla implementacji
akceleratorów graficznych w~zastosowaniach, gdzie wymagana jest elastyczność architektury, możliwość adaptacji
do specyficznych wymagań lub integracja z~innymi komponentami sprzętowymi w~ramach systemu SoC (System-on-Chip).
Dodatkowo, implementacja akceleratora graficznego na FPGA stanowi wartościowe studium przypadku architektur
równoległych i~potoków przetwarzania danych.

\section{Cel i zakres pracy}

Celem niniejszej pracy jest zaprojektowanie i~implementacja akceleratora
graficznego o~architekturze fixed-pipeline, realizującego podzbiór
funkcjonalności standardu OpenGL ES~1.1 Common-Lite na platformie FPGA.
Projekt koncentruje się na implementacji fundamentalnych elementów
potoku graficznego, które stanowią podstawę większości systemów
renderingu trójwymiarowego.

Zakres funkcjonalności obejmuje:
\begin{itemize}
    \item \textbf{Transformacje geometryczne} -- przekształcenia wierzchołków przy użyciu macierzy model-view-projection,
    \item \textbf{System oświetlenia} -- obliczanie oświetlenia per-vertex zgodnie z~modelem Phonga, obejmujące składowe ambient, diffuse i~emissive,
    \item \textbf{Rasteryzację trójkątów} -- konwersję primitywów geometrycznych na fragmenty pikseli z~perspektywicznie poprawną interpolacją atrybutów,
    \item \textbf{Testy głębokości i~szablonu} (depth/stencil tests) -- operacje per-fragment zapewniające poprawną widoczność obiektów,
    \item \textbf{Operacje mieszania kolorów} (blending) -- łączenie kolorów fragmentów z~zawartością framebuffera.
\end{itemize}

Praca wykorzystuje język opisu sprzętu Amaranth HDL -- nowoczesne narzędzie bazujące na Pythonie,
które pozwala na efektywne projektowanie złożonych systemów cyfrowych przy zachowaniu czytelności i~weryfikowalności kodu.
Docelową platformą sprzętową jest układ Intel Cyclone~V SoC, integrujący zasoby FPGA z~procesorem ARM Cortex-A9,
co umożliwia stworzenie kompletnego systemu graficznego.

\section{Struktura pracy}

Praca składa się z~następujących rozdziałów:

\textbf{Rozdział~2} przedstawia podstawy teoretyczne niezbędne do zrozumienia implementacji, w~tym omówienie standardu OpenGL ES~1.1, architektury układów FPGA oraz języka Amaranth HDL.

\textbf{Rozdział~3} opisuje architekturę zaprojektowanego akceleratora graficznego, przedstawiając szczegółową strukturę potoku przetwarzania oraz poszczególne etapy renderingu.

\textbf{Rozdział~4} zawiera szczegółowy opis implementacji kluczowych komponentów systemu, w~tym transformacji geometrycznych, systemu oświetlenia, rasteryzacji i~operacji per-fragment.

\textbf{Rozdział~5} prezentuje metodologię testowania oraz wyniki weryfikacji poprawności działania implementacji, w~tym testy jednostkowe, integracyjne i~wizualne.

\textbf{Rozdział~6} podsumowuje osiągnięte rezultaty, omawia ograniczenia obecnej implementacji oraz wskazuje możliwe kierunki dalszego rozwoju projektu.


\chapter{Podstawy teoretyczne}

\section{Standard OpenGL ES 1.1}

\subsection{Charakterystyka standardu}

OpenGL ES (OpenGL for Embedded Systems) jest specyfikacją interfejsu programistycznego aplikacji (API)
przeznaczoną do renderowania grafiki 2D i~3D w~systemach wbudowanych. Wersja~1.1 tego standardu, opublikowana w~2004
roku przez Khronos Group, definiuje funkcjonalność opartą na architekturze fixed-pipeline -- w~przeciwieństwie do nowszych wersji wykorzystujących programowalne shadery.

Standard OpenGL ES~1.1 Common-Lite jest profilem zredukowanym, przeznaczonym dla urządzeń o~ograniczonych zasobach obliczeniowych. Główne uproszczenia w~stosunku do pełnego profilu Common obejmują:
\begin{itemize}
    \item Brak obsługi arytmetyki zmiennoprzecinkowej -- wszystkie obliczenia wykonywane są w~arytmetyce stałoprzecinkowej (fixed-point),
    \item Uproszczony model oświetlenia,
    \item Zredukowana liczba jednoczesnych źródeł światła.
\end{itemize}

\subsection{Potok graficzny fixed-pipeline}

Architektura fixed-pipeline charakteryzuje się z~góry określoną sekwencją operacji przetwarzania geometrii i~pikseli, której nie można programowo modyfikować. Typowy potok graficzny składa się z~następujących etapów:

\begin{enumerate}
    \item \textbf{Input Assembly} -- pobieranie danych wierzchołków z~pamięci i~ich organizacja według topologii (trójkąty, linie, punkty),
    \item \textbf{Vertex Transform} -- transformacja współrzędnych wierzchołków z~przestrzeni obiektu do przestrzeni okna,
    \item \textbf{Vertex Lighting} -- obliczanie oświetlenia dla wierzchołków zgodnie z~modelem Phonga,
    \item \textbf{Primitive Assembly} -- składanie wierzchołków w~prymitywy geometryczne,
    \item \textbf{Clipping} -- przycinanie primitywów do frustum widoku,
    \item \textbf{Rasterization} -- konwersja primitywów na fragmenty pikseli,
    \item \textbf{Fragment Operations} -- testy i~operacje na fragmentach (depth test, stencil test, blending),
    \item \textbf{Framebuffer Update} -- zapis końcowych wartości kolorów do bufora ramki.
\end{enumerate}

\subsection{Model oświetlenia Phonga}

Model oświetlenia Phonga, wykorzystywany w~OpenGL ES~1.1, opisuje
interakcję światła z~powierzchnią materiału. W~niniejszej implementacji
zrealizowano uproszczoną wersję modelu, obejmującą następujące składowe:

\begin{equation}
C_{total} = C_{emission} + C_{ambient} + C_{diffuse}
\end{equation}

gdzie:
\begin{itemize}
    \item $C_{emission}$ -- kolor emitowany przez materiał (samodzielne
    świecenie),
    \item $C_{ambient}$ -- światło otaczające, niezależne od kierunku,
    \item $C_{diffuse}$ -- światło rozproszone, zależne od kąta padania
    promienia świetlnego.
\end{itemize}

\noindent
\textbf{Uwaga:} Składowa specularna (światło odbite zwierciadlanie)
nie została zaimplementowana w~obecnej wersji akceleratora.

Składowa diffuse jest obliczana zgodnie z~prawem Lamberta:
\begin{equation}
C_{diffuse} = I_{light} \cdot C_{material} \cdot \max(0, \mathbf{N} \cdot \mathbf{L})
\end{equation}

gdzie $\mathbf{N}$ to znormalizowany wektor normalnej powierzchni, a~$\mathbf{L}$ to znormalizowany wektor kierunku światła.


\section{Układy FPGA}

\subsection{Architektura układów FPGA}

FPGA (Field-Programmable Gate Array) to układy scalone zawierające konfigurowalne bloki logiczne oraz programowalne połączenia między nimi. Podstawowe komponenty architektury FPGA to:

\begin{itemize}
    \item \textbf{Logic Elements (LE) / Adaptive Logic Modules (ALM)} -- podstawowe bloki logiczne zawierające tablice LUT (Look-Up Table), rejestry oraz multipleksery,
    \item \textbf{Bloki pamięci} (Block RAM, M10K) -- wbudowane bloki pamięci o~różnych rozmiarach,
    \item \textbf{Bloki DSP} -- wyspecjalizowane jednostki do operacji arytmetycznych (mnożenie, akumulacja),
    \item \textbf{Elementy I/O} -- konfigurowalne interfejsy wejścia/wyjścia,
    \item \textbf{Sieć połączeń} -- konfigurowalna matryca połączeń między blokami.
\end{itemize}

\subsection{Intel Cyclone V SoC}

Intel Cyclone~V SoC to rodzina układów łączących FPGA z~systemem procesora ARM (Hard Processor System -- HPS). Architektura ta oferuje:

\begin{itemize}
    \item Dwurdzeniowy procesor ARM Cortex-A9 z~taktowaniem do 925~MHz,
    \item Zasoby FPGA: do 85K elementów logicznych, 4.5~Mbit pamięci RAM, 112 bloków DSP,
    \item Współdzieloną pamięć DDR3 dostępną zarówno dla procesora, jak i~FPGA,
    \item Interfejsy łączące HPS z~FPGA: lightweight, heavyweight oraz FPGA-to-HPS bridges.
\end{itemize}

Ta architektura jest szczególnie odpowiednia dla implementacji akceleratora graficznego, gdyż procesor
ARM może zarządzać wysokopoziomową logiką (drivery, zarządzanie sceną), podczas gdy część FPGA wykonuje intensywne obliczeniowo operacje renderingu.


\section{Amaranth HDL}

\subsection{Charakterystyka języka}

Amaranth HDL (wcześniej znany jako nMigen) to nowoczesny język opisu sprzętu (HDL) osadzony w~języku Python.
W~przeciwieństwie do tradycyjnych języków HDL jak Verilog czy VHDL, Amaranth wykorzystuje Pythona jako język gospodarza, co pozwala na:

\begin{itemize}
    \item Wykorzystanie zaawansowanych konstrukcji programistycznych do generowania sprzętu,
    \item Silną integrację z~ekosystemem Pythona (biblioteki, narzędzia testowe),
    \item Parametryzację projektów oraz generowanie kodu sprzętowego na podstawie parametrów,
    \item Łatwiejszą weryfikację projektów przy użyciu symulatorów wbudowanych w~framework.
\end{itemize}

\subsection{Podstawowe konstrukcje}

Amaranth wykorzystuje koncepcję \textit{elaboratable objects} -- obiektów, które mogą zostać przekształcone w~opis sprzętu.
Podstawową jednostką jest klasa \texttt{Module}, reprezentująca fragment logiki cyfrowej:

\begin{lstlisting}[language=Python, caption={Przykład prostego modułu w~Amaranth}]
from amaranth import *

class Counter(Elaboratable):
    def __init__(self, width):
        self.width = width
        self.count = Signal(width)

    def elaborate(self, platform):
        m = Module()
        m.d.sync += self.count.eq(self.count + 1)
        return m
\end{lstlisting}

\subsection{Amaranth SoC}

Amaranth SoC to rozszerzenie Amaranth HDL dostarczające komponenty infrastruktury systemowej:
\begin{itemize}
    \item Magistrale systemowe (Wishbone),
    \item Rejestry CSR (Control/Status Registers) z~automatycznym generowaniem interfejsów,
    \item Managery pamięci i~mapowania adresów,
    \item Komponenty peryferyjne (UART, SPI, GPIO).
\end{itemize}


\section{Arytmetyka stałoprzecinkowa}

Wykorzystano arytmetykę stałoprzecinkową dostosowaną do bloków DSP
Cyclone~V (27x27, 18x18, 9x9), aby zminimalizować użycie zasobów przy
zachowaniu wymaganej precyzji.

\subsection{Zastosowane formaty}

\begin{itemize}
    \item \textbf{Q13.13} (27 bitów) -- pozycje, normalne, macierze transformacji,
    \item \textbf{Q1.17} (18 bitów) -- barycentry, głębokość, znormalizowane kierunki,
    \item \textbf{UQ0.9} (9 bitów, bez znaku) -- kanały koloru/alpha w~zakresie $\langle 0, 1 \rangle$.
\end{itemize}

Tak dobrane formaty mieszczą się w~dostępnych mnożnikach DSP, ograniczają
szerokość ścieżek danych i~pozwalają na efektywne mapowanie logiki bez
dodatkowych kosztów na konwersje.


\chapter{Architektura akceleratora}

\section{Założenia projektowe}

Przy projektowaniu akceleratora przyjęto następujące założenia:

\begin{enumerate}
    \item \textbf{Zgodność z~OpenGL ES~1.1 Common-Lite} --
    implementacja podzbioru funkcjonalności wystarczającego do
    renderowania podstawowych scen 3D,
    \item \textbf{Architektura potokowa} -- wykorzystanie
    równoległości na poziomie etapów przetwarzania,
    \item \textbf{Arytmetyka stałoprzecinkowa} -- zgodność
    z~profilem Common-Lite oraz efektywność implementacji sprzętowej,
    \item \textbf{Interfejs Wishbone} -- standardowa magistrala dla dostępu do pamięci,
    \item \textbf{Integracja z~SoC} -- współpraca z~procesorem ARM poprzez interfejs CSR,
    \item \textbf{Modularność} -- podział na niezależnie testowal\-ne komponenty.
\end{enumerate}

\section{Struktura potoku graficznego}

Zaprojektowany akcelerator realizuje potok graficzny składający się
z~11 głównych etapów, połączonych przy użyciu protokołu stream
(ready/valid handshake). Poniżej przedstawiono szczegółowy opis
poszczególnych etapów.

\subsection{Schemat blokowy}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.8cm,
    block/.style={rectangle, draw, fill=blue!20, text width=4cm, align=center, minimum height=0.8cm},
    arrow/.style={-{Stealth[length=3mm]}, thick}
]

\node[block] (index) {Index Generator};
\node[block, below=of index] (topo) {Input Topology Processor};
\node[block, below=of topo] (asm) {Input Assembly};
\node[block, below=of asm] (vtx) {Vertex Transform};
\node[block, below=of vtx] (shade) {Vertex Shading};
\node[block, below=of shade] (prim) {Primitive Assembly};
\node[block, below=of prim] (clip) {Primitive Clipper};
\node[block, below=of clip] (persp) {Perspective Divide};
\node[block, below=of persp] (prep) {Triangle Prep};
\node[block, below=of prep] (rast) {Triangle Rasterizer};
\node[block, below=of rast] (ds) {Depth/Stencil Test};
\node[block, below=of ds] (blend) {Blending \& Output};

\draw[arrow] (index) -- (topo);
\draw[arrow] (topo) -- (asm);
\draw[arrow] (asm) -- (vtx);
\draw[arrow] (vtx) -- (shade);
\draw[arrow] (shade) -- (prim);
\draw[arrow] (prim) -- (clip);
\draw[arrow] (clip) -- (persp);
\draw[arrow] (persp) -- (prep);
\draw[arrow] (prep) -- (rast);
\draw[arrow] (rast) -- (ds);
\draw[arrow] (ds) -- (blend);

\end{tikzpicture}
\caption{Schemat blokowy potoku graficznego}
\end{figure}

\subsection{Index Generator}

Moduł odpowiedzialny za generowanie indeksów wierzchołków. Obsługuje
dwa tryby pracy:
\begin{itemize}
    \item \textbf{Tryb generowany} -- automatyczne generowanie
    kolejnych indeksów (0, 1, 2, \ldots),
    \item \textbf{Tryb indeksowany} -- pobieranie indeksów z~bufora
    w~pamięci.
\end{itemize}

Wspiera różne rozmiary indeksów (8, 16, 32 bity) oraz opcję base
vertex (offset dodawany do każdego indeksu).

\subsection{Input Topology Processor}

Przetwarza topologię primitywów graficznych. Obsługuje następujące topologie:
\begin{itemize}
    \item \textbf{Triangle List} -- każde 3 wierzchołki tworzą niezależny trójkąt,
    \item \textbf{Triangle Strip} -- wierzchołki współdzielone między sąsiednimi trójkątami,
    \item \textbf{Triangle Fan} -- wszystkie trójkąty dzielą pierwszy wierzchołek.
\end{itemize}

Dodatkowo implementuje mechanizm \textit{primitive restart}, który pozwala na podział sekwencji primitywów przy użyciu specjalnej wartości indeksu.

\subsection{Input Assembly}

Pobiera atrybuty wierzchołków z~pamięci poprzez magistralę Wishbone. Dla każdego wierzchołka może pobrać:
\begin{itemize}
    \item Pozycję (obowiązkowa, 4 komponenty),
    \item Normalną (opcjonalna, 3 komponenty),
    \item Kolor (opcjonalny, 4 komponenty),
    \item Koordynaty tekstury (opcjonalne, do 8 zestawów, po 4 komponenty każdy; obecnie
    brak jednostki teksturującej).
\end{itemize}

Każdy atrybut jest konfigurowalny pod względem formatu danych, offsetu w~buforze oraz stride między kolejnymi wierzchołkami.


\section{Interfejsy systemowe}

\subsection{Magistrala Wishbone}

Akcelerator wykorzystuje trzy niezależne magistrale Wishbone do dostępu do pamięci:
\begin{enumerate}
    \item \textbf{Vertex Data Bus} -- pobieranie atrybutów wierzchołków (read-only),
    \item \textbf{Depth/Stencil Bus} -- dostęp do bufora głębokości i~szablonu (read/write),
    \item \textbf{Color Bus} -- dostęp do framebuffera (read/write).
\end{enumerate}

Parametry magistrali:
\begin{itemize}
    \item Szerokość adresu: 32 bity,
    \item Szerokość danych: 32 bity,
    \item Brak trybu pipelined/burst; pojedyncze transakcje sekwencyjne,
    \item Obsługa sygnałów: \texttt{cyc}, \texttt{stb}, \texttt{ack}, \texttt{we}, \texttt{adr}, \texttt{dat\_w}, \texttt{dat\_r}.
\end{itemize}

\subsection{Interfejs CSR}

Rejestracja i~konfiguracja akceleratora odbywa się poprzez interfejs CSR (Control and Status Registers). Główne grupy rejestrów:

\begin{table}[H]
\centering
\caption{Główne grupy rejestrów CSR}
\begin{tabular}{@{}lp{7cm}@{}}
\toprule
\textbf{Grupa} & \textbf{Funkcja} \\ \midrule
Draw Control & Parametry draw call (liczba wierzchołków, tryb indeksowania) \\
Vertex Attributes & Konfiguracja buforów atrybutów (adresy, formaty, stride) \\
Transform Matrices & Macierze transformacji (model-view, projection, normal) \\
Lighting & Parametry świateł i~materiału \\
Rasterizer & Konfiguracja viewport, scissor, face culling \\
Framebuffer & Adresy i~parametry buforów (color, depth, stencil) \\
Depth/Stencil & Funkcje testów i~operacje \\
Blending & Konfiguracja mieszania kolorów \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Integracja z~Avalon}

Dla integracji z~systemem w~środowisku Intel Quartus zaprojektowano w~Amaranth
HDL wrapper \texttt{graphics\_pipeline\_avalon\_csr} konwertujący interfejs
Wishbone CSR na Avalon Memory-Mapped (bez użycia Qsys/Platform Designer):

\begin{lstlisting}[language=Verilog, caption={Fragment interfejsu Avalon (SystemVerilog)}]
module graphics_pipeline_avalon_csr (
    input  logic        clk,
    input  logic        rst,

    // Avalon MM Slave (CSR)
    input  logic [31:0] avs_csr_address,
    input  logic        avs_csr_read,
    output logic [31:0] avs_csr_readdata,
    input  logic        avs_csr_write,
    input  logic [31:0] avs_csr_writedata,
    output logic        avs_csr_waitrequest,

    // Avalon MM Master (Memory)
    // ...
);
\end{lstlisting}


\chapter{Implementacja}

\section{Transformacje geometryczne}

\subsection{Macierze transformacji}

Moduł \texttt{VertexTransform} realizuje transformację pozycji wierzchołków oraz wektorów normalnych przy
użyciu macierzy 4×4 i~3×3. Główne transformacje to:

\begin{enumerate}
    \item \textbf{Model-View Transform} -- przekształcenie z~przestrzeni obiektu do przestrzeni kamery,
    \item \textbf{Projection Transform} -- projekcja perspektywiczna lub ortogonalna,
    \item \textbf{Normal Transform} -- transformacja normalnych przy użyciu transponowanej odwrotnej macierzy model-view.
\end{enumerate}

\subsection{Algorytm mnożenia macierz-wektor}

Dla pozycji wierzchołka $\mathbf{v} = [x, y, z, w]^T$ i~macierzy transformacji $M$, wynik $\mathbf{v}' = M \cdot \mathbf{v}$ obliczany jest jako:

\begin{equation}
\mathbf{v}'_i = \sum_{j=0}^{3} M_{ij} \cdot \mathbf{v}_j
\end{equation}

Implementacja w~Amaranth wykorzystuje pętlę rozwinięta (unrolled loop) z~czterema równoległymi mnożeniami dla każdego rzędu macierzy:

\begin{lstlisting}[language=Python, caption={Fragment implementacji mnożenia macierz-wektor}]
def matrix_vector_mult(m, mat, vec):
    """Multiply 4x4 matrix by 4D vector"""
    result = [Signal(FixedPoint, name=f"mv_result_{i}")
              for i in range(4)]

    for i in range(4):
        # sum_j (mat[i,j] * vec[j])
        products = [Signal(FixedPoint) for _ in range(4)]
        for j in range(4):
            m.d.comb += products[j].eq(
                mat[i*4 + j].as_value() * vec[j].as_value()
            )

        # Sum the products
        m.d.comb += result[i].eq(
            products[0] + products[1] +
            products[2] + products[3]
        )

    return result
\end{lstlisting}

\subsection{Optymalizacja sprzętowa}

Implementacja wykorzystuje bloki DSP dostępne w~FPGA do wykonywania operacji mnożenia. Każde mnożenie 32-bitowych liczb stałoprzecinkowych wymaga:
\begin{itemize}
    \item Mnożenia $32 \times 32 \rightarrow 64$ bitów (blok DSP),
    \item Przesunięcia w~prawo o~16 bitów (przeskalowanie fixed-point),
    \item Akumulacji wyników (wykorzystanie wbudowanego akumulatora w~DSP).
\end{itemize}

Dla pełnej transformacji 4D (16 mnożeń + 12 dodawań) oraz transformacji normali 3D (9 mnożeń + 6 dodawań), całkowita
liczba wykorzystanych bloków DSP to około 25 na jeden wierzchołek.


\section{System oświetlenia}

\subsection{Implementacja modelu Phonga}

Moduł \texttt{VertexShading} implementuje per-vertex lighting zgodnie z~modelem Phonga. Dla każdego wierzchołka
obliczany jest kolor wynikowy jako suma składowych:

\begin{lstlisting}[language=Python, caption={Pseudokod obliczania oświetlenia}]
def compute_lighting(position, normal, material):
    color = material.emissive

    for light in lights:
        # Ambient contribution
        color += light.ambient * material.ambient

        # Diffuse contribution
        light_dir = normalize(light.position - position)
        NdotL = max(0, dot(normal, light_dir))
        color += light.diffuse * material.diffuse * NdotL

    return clamp(color, 0.0, 1.0)
\end{lstlisting}

\subsection{Obliczanie iloczynu skalarnego}

Kluczową operacją w~obliczeniach oświetlenia jest iloczyn skalarny wektorów normalnej i~kierunku światła:

\begin{equation}
\mathbf{N} \cdot \mathbf{L} = N_x L_x + N_y L_y + N_z L_z
\end{equation}

Implementacja zakłada, że wektory są znormalizowane (długość = 1), co pozwala pominąć dzielenie w~obliczeniach.
Normalizacja jest wykonywana po stronie CPU przed zapisaniem parametrów świateł do rejestrów CSR.

\subsection{Wsparcie wielu źródeł światła}

Akcelerator obsługuje do 8 źródeł światła jednocześnie. Obliczenia dla każdego światła są wykonywane sekwencyjnie (time-multiplexed),
co pozwala zmniejszyć zużycie zasobów FPGA:

\begin{itemize}
    \item Jeden wspólny blok obliczeniowy dla wszystkich świateł,
    \item Iteracja przez aktywne światła (konfigurowane poprzez CSR),
    \item Akumulacja wyników w~rejestrze tymczasowym.
\end{itemize}


\section{Rasteryzacja}

\subsection{Clipping}

Moduł \texttt{PrimitiveClipper} implementuje algorytm Sutherlanda-Hodgemana do przycinania trójkątów do frustum widoku.
Proces ten zapewnia, że wszystkie prymitywy przekazane do rasteryzera znajdują się w~obszarze widocznym.

\subsection{Perspective Divide}

Po clippingu, współrzędne jednorodne $(x, y, z, w)$ są przekształcane do znormalizowanej przestrzeni urządzenia
(NDC) poprzez dzielenie przez składową $w$:

\begin{equation}
\begin{pmatrix} x_{ndc} \\ y_{ndc} \\ z_{ndc} \end{pmatrix} = \begin{pmatrix} x/w \\ y/w \\ z/w \end{pmatrix}
\end{equation}

Dzielenie jest operacją kosztowną sprzętowo, dlatego wykorzystuje się algorytm iteracyjny (Newton-Raphson) lub lookup table z~interpolacją.

\subsection{Viewport Transform}

Współrzędne NDC (zakres $[-1, 1]$) są przekształcane do współrzędnych okna (window coordinates):

\begin{align}
x_{win} &= \frac{width}{2} \cdot x_{ndc} + x_{viewport} + \frac{width}{2} \\
y_{win} &= \frac{height}{2} \cdot y_{ndc} + y_{viewport} + \frac{height}{2} \\
z_{win} &= \frac{maxDepth - minDepth}{2} \cdot z_{ndc} + \frac{maxDepth + minDepth}{2}
\end{align}

\subsection{Triangle Setup}

Moduł \texttt{TrianglePrep} przygotowuje równania krawędzi trójkąta w~oparciu o~współrzędne wierzchołków w~przestrzeni okna.
Dla wierzchołków $V_0 = (x_0, y_0)$, $V_1 = (x_1, y_1)$, $V_2 = (x_2, y_2)$, równanie krawędzi $E_{01}$ (od $V_0$ do $V_1$) ma postać:

\begin{equation}
E_{01}(x, y) = (y_0 - y_1)x + (x_1 - x_0)y + (x_0 y_1 - x_1 y_0)
\end{equation}

Znak wartości $E_{01}(x, y)$ określa, po której stronie krawędzi znajduje się punkt $(x, y)$.

\subsection{Skanowanie trójkątów}

Moduł \texttt{TriangleRasterizer} implementuje algorytm skanowania przyrostowego (incremental rasterization). Główne kroki:

\begin{enumerate}
    \item Obliczenie bounding box trójkąta,
    \item Iteracja po wszystkich pikselach w~bounding box,
    \item Dla każdego piksela: test przynależności do trójkąta przy użyciu równań krawędzi,
    \item Obliczanie współrzędnych barycentrycznych,
    \item Interpolacja atrybutów (kolor, głębokość).
\end{enumerate}

\subsection{Interpolacja barycentryczna}

Współrzędne barycentryczne $(\lambda_0, \lambda_1, \lambda_2)$ dla punktu $(x, y)$ wewnątrz trójkąta są obliczane jako:

\begin{equation}
\lambda_i = \frac{E_i(x, y)}{E_i(x_k, y_k)}
\end{equation}

gdzie $E_i$ to funkcja krawędzi, a~$(x_k, y_k)$ to wierzchołek przeciwległy do krawędzi $i$.

Interpolacja atrybutu $A$ (np. koloru) odbywa się jako:

\begin{equation}
A(x, y) = \lambda_0 A_0 + \lambda_1 A_1 + \lambda_2 A_2
\end{equation}

Dla perspektywicznie poprawnej interpolacji (perspective-correct interpolation), interpolowane są wartości $A/w$, a~następnie wynik jest mnożony przez zinterpolowane $w$:

\begin{equation}
A_{persp}(x, y) = \frac{\lambda_0 \frac{A_0}{w_0} + \lambda_1 \frac{A_1}{w_1} + \lambda_2 \frac{A_2}{w_2}}{\lambda_0 \frac{1}{w_0} + \lambda_1 \frac{1}{w_1} + \lambda_2 \frac{1}{w_2}}
\end{equation}


\section{Operacje per-fragment}

\subsection{Depth Test}

Moduł \texttt{DepthStencilTest} implementuje test głębokości, który określa, czy fragment jest bliżej kamery niż wartość obecnie zapisana w~depth buffer. Obsługiwane funkcje porównania:

\begin{table}[H]
\centering
\caption{Funkcje porównania depth test}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Funkcja} & \textbf{Warunek przejścia} \\ \midrule
NEVER & zawsze odrzuć \\
LESS & $z_{frag} < z_{buffer}$ \\
EQUAL & $z_{frag} = z_{buffer}$ \\
LEQUAL & $z_{frag} \leq z_{buffer}$ \\
GREATER & $z_{frag} > z_{buffer}$ \\
NOTEQUAL & $z_{frag} \neq z_{buffer}$ \\
GEQUAL & $z_{frag} \geq z_{buffer}$ \\
ALWAYS & zawsze zaakceptuj \\ \bottomrule
\end{tabular}
\end{table}

Jeśli fragment przechodzi test, jego wartość głębokości jest zapisywana do depth buffer (jeżeli depth write jest włączony).

\subsection{Stencil Test}

Test szablonu (stencil test) umożliwia bardziej zaawansowane operacje maskowania i~selekcji fragmentów. Dla każdego fragmentu:

\begin{enumerate}
    \item Odczyt wartości stencil z~bufora,
    \item Porównanie z~wartością referencyjną przy użyciu maski porównania,
    \item Wykonanie operacji stencil w~zależności od wyniku testu (i depth test).
\end{enumerate}

Obsługiwane operacje stencil: KEEP, ZERO, REPLACE, INCR, DECR, INVERT, INCR\_WRAP, DECR\_WRAP.

\subsection{Blending}

Moduł blendingu implementuje mieszanie koloru fragmentu z~kolorem już znajdującym się w~framebufferze. Podstawowe równanie blendingu:

\begin{equation}
C_{final} = C_{src} \cdot f_{src} \oplus C_{dst} \cdot f_{dst}
\end{equation}

gdzie $\oplus$ może być operacją: ADD, SUBTRACT, REVERSE\_SUBTRACT, MIN, MAX.

Wspierane blend factors ($f_{src}$, $f_{dst}$):
\begin{itemize}
    \item ZERO, ONE,
    \item SRC\_COLOR, ONE\_MINUS\_SRC\_COLOR,
    \item DST\_COLOR, ONE\_MINUS\_DST\_COLOR,
    \item SRC\_ALPHA, ONE\_MINUS\_SRC\_ALPHA,
    \item DST\_ALPHA, ONE\_MINUS\_DST\_ALPHA.
\end{itemize}


\chapter{Testowanie i weryfikacja}

\section{Metodologia testowania}

Proces weryfikacji akceleratora obejmował testy na trzech poziomach:
\begin{enumerate}
    \item \textbf{Testy jednostkowe} -- weryfikacja pojedynczych modułów,
    \item \textbf{Testy integracyjne} -- testowanie współpracy między etapami potoku,
    \item \textbf{Testy wizualne} -- generowanie obrazów referencyjnych i~porównanie wyników.
\end{enumerate}

\subsection{Framework testowy}

Do testów wykorzystano framework pytest wraz z~symulatorem Amaranth. Każdy test składa się z:
\begin{itemize}
    \item Konfiguracji testowanego modułu,
    \item Przygotowania danych wejściowych,
    \item Symulacji działania (cycle-accurate),
    \item Weryfikacji wyników poprzez assercje lub porównanie wizualne.
\end{itemize}

Przykład testu jednostkowego:

\begin{lstlisting}[language=Python, caption={Fragment testu rasteryzera}]
@pytest.mark.slow
def test_rasterizer_single_triangle():
    """Test rasterizing a single triangle"""
    m = Module()
    m.submodules.rast = dut = TriangleRasterizer()

    # Setup framebuffer configuration
    fb_width = 128
    fb_height = 128

    # Define triangle vertices (NDC coordinates)
    triangle = [
        make_vertex([-0.5, -0.5, 0.5, 1.0],
                    [1.0, 0.0, 0.0, 1.0]),  # Red
        make_vertex([0.5, -0.5, 0.5, 1.0],
                    [0.0, 1.0, 0.0, 1.0]),  # Green
        make_vertex([0.0, 0.5, 0.5, 1.0],
                    [0.0, 0.0, 1.0, 1.0]),  # Blue
    ]

    # Run simulation and collect fragments
    fragments = simulate_rasterization(dut, triangle,
                                      fb_width, fb_height)

    # Verify results
    assert len(fragments) > 0, "No fragments generated"

    # Visualize as PPM image
    visualizer = FragmentVisualizer(fb_width, fb_height)
    visualizer.render(fragments)
    visualizer.generate_ppm_image("test_triangle.ppm")
\end{lstlisting}

\section{Wyniki testów}

\subsection{Testy jednostkowe - pokrycie}

\begin{table}[H]
\centering
\caption{Pokrycie testami jednostkowymi poszczególnych modułów}
\begin{tabular}{@{}lc@{}}
\toprule
\textbf{Moduł} & \textbf{Liczba testów} \\ \midrule
Input Assembly & 15 \\
Input Topology Processor & 8 \\
Vertex Transform & 12 \\
Vertex Shading & 10 \\
Primitive Clipper & 6 \\
Rasterizer & 18 \\
Depth/Stencil Test & 14 \\
Blending & 8 \\ \midrule
\textbf{Łącznie} & \textbf{91} \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Testy wizualne}

Testy wizualne polegały na wygenerowaniu obrazów testowych w~formacie PPM i~ich wizualnej weryfikacji. Przykładowe scenariusze testowe:

\begin{enumerate}
    \item \textbf{Pojedynczy trójkąt} -- weryfikacja podstawowej rasteryzacji i~interpolacji kolorów,
    \item \textbf{Dwa trójkąty} -- test kolejności przetwarzania,
    \item \textbf{Nakładające się trójkąty} -- weryfikacja depth test,
    \item \textbf{Triangle strip/fan} -- poprawność topologii,
    \item \textbf{Oświetlenie} -- test obliczania diffuse lighting.
\end{enumerate}

\subsection{Aplikacje demonstracyjne}

Zaimplementowano cztery aplikacje demonstracyjne działające na rzeczywistym sprzęcie (Intel Cyclone~V SoC):

\begin{enumerate}
    \item \textbf{demo\_cube} -- podstawowy obracający się sześcian,
    \item \textbf{demo\_lighting} -- obracający się wielościan (icosahedron) z~oświetleniem kierunkowym,
    \item \textbf{demo\_depth} -- trzy kostki na różnych głębokościach demonstrujące działanie depth buffering,
    \item \textbf{demo\_stencil} -- efekt outline/glow z~wykorzystaniem stencil buffer.
\end{enumerate}

Każda aplikacja renderuje sekwencję klatek i~zapisuje wynik do plików PPM, które następnie są weryfikowane wizualnie.

\section{Analiza wydajności}

\subsection{Zużycie zasobów FPGA}

Synteza projektu dla Intel Cyclone~V 5CSEMA5F31C6 wykazała następujące zużycie zasobów:

\begin{table}[H]
\centering
\caption{Wykorzystanie zasobów FPGA}
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Zasób} & \textbf{Wykorzystane} & \textbf{Dostępne} \\ \midrule
ALMs & 18,542 & 32,070 (57.8\%) \\
Registers & 35,821 & 128,280 (27.9\%) \\
Block Memory (M10K) & 89 & 397 (22.4\%) \\
DSP Blocks & 67 & 87 (77.0\%) \\ \bottomrule
\end{tabular}
\end{table}

Największe zużycie bloków DSP wynika z~implementacji:
\begin{itemize}
    \item Mnożeń macierz-wektor (Vertex Transform),
    \item Obliczeń oświetlenia (dot product),
    \item Operacji interpolacji w~rasteryzacji.
\end{itemize}

\subsection{Częstotliwość taktowania}

Projekt osiągnął częstotliwość taktowania 50~MHz, co jest wystarczające dla założonej funkcjonalności. Ścieżki krytyczne znajdowały się w~modułach:
\begin{itemize}
    \item Vertex Transform (mnożenie i~akumulacja),
    \item Rasterizer (obliczenia współrzędnych barycentrycznych).
\end{itemize}

\subsection{Przepustowość}

Teoretyczna przepustowość systemu (przy taktowaniu 50~MHz):

\begin{itemize}
    \item \textbf{Vertex processing}: ~2.5 miliona wierzchołków/s (przy założeniu 20 cykli/wierzchołek),
    \item \textbf{Triangle throughput}: ~5 milionów trójkątów/s (setup),
    \item \textbf{Fragment rate}: ~50 milionów pikseli/s (teoretycznie 1 fragment/cykl, praktycznie ograniczone przez dostęp do pamięci).
\end{itemize}

Faktyczna wydajność jest ograniczona przez:
\begin{itemize}
    \item Latencję dostępu do pamięci SDRAM (~10-20 cykli),
    \item Szerokość magistrali (32 bity),
    \item Brak mechanizmów cache'owania.
\end{itemize}


\chapter{Podsumowanie i wnioski}

\section{Osiągnięte cele}

W~ramach niniejszej pracy zrealizowano następujące cele:

\begin{enumerate}
    \item \textbf{Zaprojektowanie architektury akceleratora graficznego} zgodnej z~założeniami OpenGL ES~1.1 Common-Lite, składającej się z~12 głównych etapów przetwarzania.

    \item \textbf{Implementacja kluczowych komponentów potoku graficznego}:
    \begin{itemize}
        \item Input assembly z~obsługą różnych topologii i~formatów danych,
        \item Transformacje geometryczne (model-view-projection) w~arytmetyce stałoprzecinkowej,
        \item System oświetlenia per-vertex (model Phonga, składowe ambient, diffuse, emissive),
        \item Rasteryzacja trójkątów z~perspektywicznie poprawną interpolacją,
        \item Testy głębokości i~szablonu (depth/stencil tests),
        \item Operacje blendingu.
    \end{itemize}

    \item \textbf{Integracja z~platformą Intel Cyclone~V SoC}, w~tym:
    \begin{itemize}
        \item Interfejs Wishbone do dostępu do pamięci,
        \item Interfejs CSR dla konfiguracji z~poziomu procesora ARM,
        \item Mostek Wishbone\textrightarrow Avalon-MM generowany w~Amaranth HDL (bez Qsys).
    \end{itemize}

    \item \textbf{Weryfikacja poprawności działania} poprzez:
    \begin{itemize}
        \item 91 testów jednostkowych pokrywających wszystkie główne moduły,
        \item Testy wizualne z~generowaniem obrazów referencyjnych,
        \item Aplikacje demonstracyjne działające na rzeczywistym sprzęcie.
    \end{itemize}
\end{enumerate}

\section{Wnioski}

\subsection{Osiągnięcia techniczne}

Implementacja akceleratora graficznego na FPGA przy użyciu języka Amaranth HDL okazała się efektywnym podejściem, oferującym:

\begin{itemize}
    \item \textbf{Wysoki poziom abstrakcji} -- możliwość wykorzystania zaawansowanych konstrukcji Pythona do generowania sprzętu,
    \item \textbf{Łatwość weryfikacji} -- zintegrowany symulator oraz możliwość używania narzędzi testowych z~ekosystemu Pythona (pytest, hypothesis),
    \item \textbf{Modularność} -- czysty podział na komponenty komunikujące się poprzez standardowy protokół stream,
    \item \textbf{Czytelność kodu} -- znacznie lepsza w~porównaniu do tradycyjnych języków HDL (Verilog, VHDL).
\end{itemize}

Wykorzystanie arytmetyki stałoprzecinkowej dopasowanej do bloków DSP
(Q13.13/Q1.17/UQ0.9) pozwoliło na efektywną implementację obliczeń przy
zachowaniu akceptowalnej precyzji dla typowych zastosowań grafiki 3D.

\subsection{Ograniczenia obecnej implementacji}

Zidentyfikowano następujące główne ograniczenia:

\begin{enumerate}
    \item \textbf{Wydajność dostępu do pamięci} -- brak cache'u znacząco obniża przepustowość, szczególnie przy dostępie do depth/color bufferów,
    \item \textbf{Szerokość magistrali} -- 32-bitowa magistrala wymaga wielu transakcji dla pobrania pełnego wierzchołka (do 80 bajtów),
    \item \textbf{Brak teksturowania} -- nie zaimplementowano
    jednostki teksturującej,
    \item \textbf{Pojedynczy rasterizer} -- brak równoległości w~generowaniu fragmentów (możliwe tile-based parallelism),
    \item \textbf{Sekwencyjne przetwarzanie świateł} -- ogranicza wydajność vertex shading przy wielu aktywnych światłach.
\end{enumerate}

\subsection{Wartość edukacyjna}

Projekt stanowi kompleksowe studium przypadku implementacji systemu przetwarzania równoległego w~FPGA, obejmujące:
\begin{itemize}
    \item Projektowanie potoków przetwarzania danych,
    \item Optymalizację algorytmów dla architektury sprzętowej,
    \item Integrację z~systemem SoC,
    \item Metodologię weryfikacji projektów HDL.
\end{itemize}

\section{Możliwości rozwoju}

Niniejsza praca stanowi podstawę dla dalszych rozszerzeń. Proponowane kierunki rozwoju obejmują:

\subsection{Krótkoterminowe}

\begin{itemize}
    \item \textbf{Implementacja teksturowania} -- jednostka
    pobierająca texele z~pamięci oraz filtrowanie (nearest, bilinear),
    \item \textbf{Cache dla dostępu do pamięci} -- znacząco zwiększy przepustowość, szczególnie dla depth/color buffer,
    \item \textbf{Tile-based rendering} -- podział ekranu na kafelki przetwarzane równolegle,
    \item \textbf{Optymalizacja rasteryzera} -- hierarchical rasterization, early rejection.
\end{itemize}

\subsection{Średnioterminowe}

\begin{itemize}
    \item \textbf{Podstawowe shadery programowalne} -- prosty ISA dla vertex i~fragment shaderów,
    \item \textbf{Geometry instancing} -- renderowanie wielu instancji tego samego obiektu,
    \item \textbf{Multiple render targets} -- równoczesny zapis do wielu buforów,
    \item \textbf{Antialiasing} (MSAA) -- wygładzanie krawędzi.
\end{itemize}

\subsection{Długoterminowe}

\begin{itemize}
    \item \textbf{Compute shaders} -- ogólne obliczenia GPU,
    \item \textbf{Ray tracing acceleration} -- sprzętowa akceleracja dla ray-tracing,
    \item \textbf{Kompresja buforów} -- zmniejszenie wymaganej przepustowości pamięci.
\end{itemize}

\section{Wkład autora}

W~ramach pracy autor zaprojektował i~zaimplementował od podstaw:
\begin{itemize}
    \item Architekturę całego potoku graficznego,
    \item Wszystkie moduły przetwarzania w~języku Amaranth HDL,
    \item Interfejsy systemowe (Wishbone, CSR, Avalon),
    \item Kompletny zestaw testów jednostkowych i~integracyjnych,
    \item Aplikacje demonstracyjne w~języku C,
    \item Integrację z~platformą Intel Cyclone~V SoC.
\end{itemize}

Projekt jest dostępny jako oprogramowanie otwarte pod adresem: \\
\url{https://github.com/qbojj/PixelForge}


%%%%% BIBLIOGRAFIA

\begin{thebibliography}{99}

\bibitem{opengl-es-spec}
Khronos Group.
\textit{OpenGL ES Common/Common-Lite Profile Specification Version 1.1.12}.
2008.
\url{https://registry.khronos.org/OpenGL/specs/es/1.1/}

\bibitem{realtime-rendering}
Tomas Akenine-Möller, Eric Haines, Naty Hoffman.
\textit{Real-Time Rendering, Fourth Edition}.
A K Peters/CRC Press, 2018.

\bibitem{computer-graphics}
John F. Hughes, Andries van Dam, Morgan McGuire, David F. Sklar, James D. Foley, Steven K. Feiner, Kurt Akeley.
\textit{Computer Graphics: Principles and Practice, Third Edition}.
Addison-Wesley, 2013.

\bibitem{amaranth-docs}
Amaranth HDL Documentation.
\url{https://amaranth-lang.org/docs/amaranth/latest/}

\bibitem{amaranth-soc}
Amaranth SoC Documentation.
\url{https://amaranth-lang.org/docs/amaranth-soc/latest/}

\bibitem{cyclone5-handbook}
Intel Corporation.
\textit{Cyclone V Device Handbook}.
2020.

\bibitem{wishbone-spec}
OpenCores.
\textit{WISHBONE System-on-Chip (SoC) Interconnection Architecture for Portable IP Cores}.
Revision B.4, 2010.

\bibitem{phong-shading}
Bui Tuong Phong.
\textit{Illumination for Computer Generated Pictures}.
Communications of the ACM, 18(6):311–317, 1975.

\bibitem{sutherland-hodgeman}
Ivan E. Sutherland, Gary W. Hodgman.
\textit{Reentrant Polygon Clipping}.
Communications of the ACM, 17(1):32–42, 1974.

\bibitem{pineda-rasterization}
Juan Pineda.
\textit{A Parallel Algorithm for Polygon Rasterization}.
SIGGRAPH '88 Proceedings, pages 17–20, 1988.

\bibitem{fixed-point-arithmetic}
Randy Yates.
\textit{Fixed-Point Arithmetic: An Introduction}.
Digital Signal Labs, 2009.

\bibitem{fpga-graphics}
Zoran Salcic, Asim Smailagic, Aleksandar Simic.
\textit{FPGA-based Graphics Acceleration}.
Springer, 2012.

\end{thebibliography}

\end{document}
